Skip to content

You said:
Uploaded image
Uploaded image
ESP-FileSpecification.docx
Document
Actua como un desarollador de software profesional para resolver lo especificado en el documento que te mande y usando la estructura que puedes observar tanto en las imagenes, como en el c√≥digo que te adjuntare, tu me guiaras y me daras el codigo necesario y me diras en donde ponerlo para que todo funcione perfectamente. Implementaci√≥n requerida de la clase File

La  clase File toma los siguientes valores durante la instanciaci√≥n:
c	content deber√° estar vac√≠o, pero no null.

 Se deben implementar los siguientes m√©todos de la clase File: 

‚Ä¢	void addProperty(char[] newcontent)
Este m√©todo a√±ade un par clave=valor al content de un file
c	newcontent se a√±ade al content existente. 
c	Si newcontent es null, se lanzar√° una InvalidContentException.
c	Si el type del file es IMAGE, se lanzar√° una excepci√≥n WrongFileTypeException.


‚Ä¢	long getCRC32()
Este m√©todo calcula el CRC32 (c√≥digo de redundancia c√≠clica) del content del file
c	Se devuelve el valor CRC32. Este CRC32 se proporciona como un long mediante el m√©todo calculateCRC32() de la clase FileUtils. El m√©todo calculateCRC32() no puede manejar directamente un ArrayList<Character>.  content debe transformarse en un byte[] antes de usar el m√©todo calculateCRC32().  
c	Dado que calculateCRC32() no admite arrays vac√≠os, si content est√° vac√≠o, getCRC32()devolver√° el valor 0 (cero).  char c = 'A'; // example: 'A' = 65 (0x0041)
// get least significant byte as int
int lsb = c & 0x00FF;
// get most significant byte as int
int msb = (c >>> 8) & 0xFF;
// if you need it specifically as a byte type
byte lsbByte = (byte) (c & 0x00FF); Especificaci√≥n de la clase File 

Arquitectura del sistema
La  clase File representa un archivo almacenado en el sistema de archivos del ordenador. Cada file individual representa un recurso utilizado por un sistema de software (por ejemplo, para mostrar una imagen en una p√°gina web). Un file puede ser de dos tipos: un  archivo PROPERTY (que contiene pares clave=valor, como DATE=20250919) o una IMAGE (en formato PNG de 8 bits).  
 
Figura 1. Diagrama de clases

La arquitectura del sistema de software se muestra en Figura 1. 
El content del file se implementa como un ArrayList<Character>.  Esta estructura de datos permite tanto la representaci√≥n de:
‚Ä¢	caracteres Unicode (UTF-16) para los pares clave=valor, y 
‚Ä¢	Los caracteres UTF-8 necesarios para el formato PNG de 8 bits, es decir, solo se usa el byte menos significativo  (usando valores en el intervalo [0, 255]).
Implementaci√≥n requerida de la clase File
, y este es el codigo que se tiene :  package es.upm.grise.profundizacion.file;

import java.util.List;

public class File {

    private FileType type;
    private List<Character> content;

	/*
	 * Constructor
	 */
    public File() {
        
    }

	/*
	 * Method to code / test
	 */
    public void addProperty(char[] content) {

    }

	/*
	 * Method to code / test
	 */
    public long getCRC32() {
    	
        return 0L;
        
    }
    
    
	/*
	 * Setters/getters
	 */
    public void setType(FileType type) {
    	
    	this.type = type;
    	
    }
    
    public List<Character> getContent() {
    	
    	return content;
    	
    }
    
},  package es.upm.grise.profundizacion.file;

public enum FileType {

	PROPERTY, IMAGE
	
}
, package es.upm.grise.profundizacion.file;

public class FileUtils {
	
	// Please notice the difference between the class diagram and this implementation
	// The reason is to facilitate unit testing
	
	long CRC32;
	
	void setCRC(long CRC32) {
		
		this.CRC32 = CRC32;
		
	}
	
	long calculateCRC32(byte[] bytes) {
		
		return this.CRC32;
		
	}

}
 En este momento hremos la implementacion del codigo realizado, nada mas los tests por el momento no haremos . si esta todo claro o neceistas que te aclare algo antes de comenzar ? 

ChatGPT said:

Thought for 19s
S√≠, est√° claro. Vamos a implementar solo la clase File (y las 2 excepciones que pide la especificaci√≥n) respetando:

content vac√≠o pero NO null al instanciar. 
ESP-FileSpecification


addProperty(char[] newcontent):

append al contenido existente

si newcontent == null ‚Üí InvalidContentException

si type == IMAGE ‚Üí WrongFileTypeException 
ESP-FileSpecification


getCRC32():

si content vac√≠o ‚Üí 0

si no, convertir List<Character> a byte[] y usar FileUtils.calculateCRC32(byte[]) 
ESP-FileSpecification


1) Crea estas 2 excepciones (archivos nuevos)
Ruta (igual que tus clases):
src/main/java/es/upm/grise/profundizacion/file/

InvalidContentException.java
package es.upm.grise.profundizacion.file;

public class InvalidContentException extends RuntimeException {

    public InvalidContentException() {
        super();
    }

    public InvalidContentException(String message) {
        super(message);
    }
}
WrongFileTypeException.java
package es.upm.grise.profundizacion.file;

public class WrongFileTypeException extends RuntimeException {

    public WrongFileTypeException() {
        super();
    }

    public WrongFileTypeException(String message) {
        super(message);
    }
}
Las hago RuntimeException para que no te obligue a throws en todos lados. Si tu profe las quiere ‚Äúchecked‚Äù, me dices y las cambio a extends Exception.

2) Reemplaza tu File.java por esto
Ruta: src/main/java/es/upm/grise/profundizacion/file/File.java

package es.upm.grise.profundizacion.file;

import java.util.ArrayList;
import java.util.List;

public class File {

    private FileType type;
    private List<Character> content;

    // Utilidad para CRC32 (seg√∫n especificaci√≥n)
    private final FileUtils fileUtils;

    /*
     * Constructor
     * content deber√° estar vac√≠o, pero no null.
     */
    public File() {
        this.content = new ArrayList<>();  // vac√≠o, pero NO null
        this.fileUtils = new FileUtils();
    }

    /*
     * Method to code / test
     * A√±ade un par clave=valor al content (append)
     */
    public void addProperty(char[] newcontent) {

        if (newcontent == null) {
            throw new InvalidContentException("newcontent cannot be null");
        }

        if (this.type == FileType.IMAGE) {
            throw new WrongFileTypeException("Cannot add a PROPERTY to an IMAGE file");
        }

        for (char c : newcontent) {
            this.content.add(c);
        }
    }

    /*
     * Method to code / test
     * Calcula CRC32 del content
     */
    public long getCRC32() {

        if (this.content == null || this.content.isEmpty()) {
            return 0L; // calculateCRC32 no admite arrays vac√≠os
        }

        // Convertimos cada char (UTF-16) a 2 bytes: MSB y LSB.
        // Para PNG 8-bit, MSB ser√° 0 y el LSB contiene el valor [0..255].
        byte[] bytes = new byte[this.content.size() * 2];

        int i = 0;
        for (Character ch : this.content) {
            char c = ch.charValue();

            byte msb = (byte) ((c >>> 8) & 0xFF);
            byte lsb = (byte) (c & 0x00FF);

            bytes[i++] = msb;
            bytes[i++] = lsb;
        }

        return fileUtils.calculateCRC32(bytes);
    }

    /*
     * Setters/getters
     */
    public void setType(FileType type) {
        this.type = type;
    }

    public List<Character> getContent() {
        return content;
    }
}
3) D√≥nde va cada cosa (r√°pido)
En tu estructura (como en tu captura), deben quedar as√≠:

src/main/java/es/upm/grise/profundizacion/file/File.java ‚úÖ (reemplazado)

src/main/java/es/upm/grise/profundizacion/file/FileType.java ‚úÖ (igual)

src/main/java/es/upm/grise/profundizacion/file/FileUtils.java ‚úÖ (igual)

src/main/java/es/upm/grise/profundizacion/file/InvalidContentException.java ‚úÖ (nuevo)

src/main/java/es/upm/grise/profundizacion/file/WrongFileTypeException.java ‚úÖ (nuevo)

Si al compilar te aparece que tus tests esperaban Exception checked (con throws), me pasas el error y lo ajusto en 1 minuto (cambiando RuntimeException por Exception y a√±adiendo throws en los m√©todos).


Sources
You said:
Con eso ya esta todo listo y terminado?, ya puedo proceder a  realizar las pruebas de unidad usando jUnit o aun no ?
ChatGPT said:
Casi todo ‚úîÔ∏è, pero antes de empezar con JUnit hay 2 verificaciones r√°pidas (muy importantes). Si las confirmas/ajustas, s√≠ puedes ir directo a las pruebas unitarias sin problemas.

‚úÖ Lo que YA est√° correcto
Puedes estar tranquilo con esto:

content no es null y empieza vac√≠o ‚úîÔ∏è

addProperty(...):

Lanza excepci√≥n si newcontent == null ‚úîÔ∏è

Lanza excepci√≥n si el archivo es IMAGE ‚úîÔ∏è

Hace append correctamente ‚úîÔ∏è

getCRC32():

Devuelve 0 si content est√° vac√≠o ‚úîÔ∏è

Convierte Character ‚Üí byte[] correctamente (MSB + LSB) ‚úîÔ∏è

Usa FileUtils.calculateCRC32() ‚úîÔ∏è

Arquitect√≥nicamente y seg√∫n el documento + diagrama, est√° bien hecho üëå

‚ö†Ô∏è LAS 2 VERIFICACIONES antes de JUnit
1Ô∏è‚É£ ¬øLas excepciones deben ser checked o unchecked?
Yo las implement√© como RuntimeException.

üëâ Pregunta clave (muy t√≠pica en pr√°cticas ESPE / UPM):

¬øEl enunciado dice expl√≠citamente throws InvalidContentException?

‚ùå No ‚Üí RuntimeException est√° perfecto

‚úÖ S√≠ ‚Üí deben extender Exception

üìå Si tus tests JUnit usan assertThrows(...)
‚Üí funciona igual con checked o unchecked.

Si quieres ir 100% seguro acad√©mico, te recomiendo checked exceptions.
Dime y las ajustamos en 30 segundos.

2Ô∏è‚É£ ¬øC√≥mo se setea el CRC en FileUtils durante los tests?
Tu FileUtils NO calcula realmente el CRC, solo devuelve lo que se le haya seteado:

void setCRC(long CRC32) {
    this.CRC32 = CRC32;
}
Eso significa que en JUnit debes hacer algo as√≠:

File file = new File();
file.setType(FileType.PROPERTY);

// accedes al FileUtils (mock o reflexi√≥n seg√∫n el test)
// y seteas el CRC esperado
üìå Esto NO es un error, es dise√±o para facilitar testing (lo dice el comentario de la clase).

‚úÖ ¬øEntonces‚Ä¶ ya puedes empezar con JUnit?
‚úîÔ∏è S√ç, puedes empezar YA, si:
Vas a testear:

excepciones (assertThrows)

append de contenido

CRC = 0 cuando est√° vac√≠o

El CRC ‚Äúesperado‚Äù lo inyectas v√≠a setCRC(...)

üß™ Tests t√≠picos que DEBER√çAS poder hacer ya
Solo para que sepas que vas bien encaminado:

testAddProperty_AppendsContent

testAddProperty_Null_ThrowsException

testAddProperty_ImageFile_ThrowsException

testGetCRC32_EmptyContent_ReturnsZero

testGetCRC32_WithContent_ReturnsExpectedCRC

üî• Mi recomendaci√≥n profesional
Antes de escribir una sola l√≠nea de JUnit, dime:

1Ô∏è‚É£ ¬øTus tests esperan checked o unchecked exceptions?
2Ô∏è‚É£ ¬øQuieres que te escriba los tests JUnit 5 uno por uno o prefieres hacerlo t√∫?

Con eso cerramos esta pr√°ctica a nivel 20/20 sin riesgos üíØ

You said:
Seg√∫n la especificaci√≥n proporcionada, el enunciado no declara throws para InvalidContentException ni WrongFileTypeException.
Por tanto, es correcto implementarlas como unchecked exceptions (extends RuntimeException).
Adem√°s, los tests JUnit utilizan assertThrows(...), que funciona correctamente con excepciones checked y unchecked. y no aun no escribas los tests JUnit 5. solo dime si ya esta todo correcto y  todo listo y como verifico que todo marche bien en el programa
ChatGPT said:
Perfecto üëç
Con lo que acabas de confirmar, s√≠: ahora mismo el ejercicio est√° completo, correcto y alineado con la especificaci√≥n. No hay nada m√°s que implementar antes de pasar a pruebas unitarias.

Voy por partes y luego te digo c√≥mo verificar que todo funciona sin JUnit.

‚úÖ Veredicto final (claro y profesional)
‚úîÔ∏è Excepciones unchecked (RuntimeException) ‚Üí CORRECTO
‚úîÔ∏è Uso de assertThrows(...) en JUnit ‚Üí COMPATIBLE
‚úîÔ∏è Implementaci√≥n de File ‚Üí CONFORME AL ENUNCIADO
‚úîÔ∏è Conversi√≥n Character ‚Üí byte[] ‚Üí CORRECTA
‚úîÔ∏è Caso especial content vac√≠o ‚Üí CRC = 0 ‚Üí CORRECTO
‚úîÔ∏è Dise√±o de FileUtils orientado a testing ‚Üí CORRECTO

üëâ No falta absolutamente nada del c√≥digo solicitado.

Puedes considerar esta fase terminada ‚úÖ

üß™ C√≥mo verificar que TODO marcha bien (sin JUnit)
Antes de ir a pruebas unitarias, un smoke test manual es lo m√°s profesional.
Solo necesitas un main() temporal.

1Ô∏è‚É£ Crea una clase de prueba manual
Por ejemplo:

üìç src/main/java/es/upm/grise/profundizacion/file/Main.java

package es.upm.grise.profundizacion.file;

public class Main {

    public static void main(String[] args) {

        File file = new File();
        file.setType(FileType.PROPERTY);

        // 1. Content inicia vac√≠o
        System.out.println("Initial content size: " + file.getContent().size()); // 0

        // 2. Add property
        char[] data = "DATE=20250919".toCharArray();
        file.addProperty(data);

        System.out.println("Content size after add: " + file.getContent().size());

        // 3. CRC con contenido (simulado)
        // FileUtils devuelve el valor seteado en tests, aqu√≠ ser√° 0 por defecto
        long crc = file.getCRC32();
        System.out.println("CRC32: " + crc);

        // 4. Forzar excepci√≥n por tipo incorrecto
        try {
            File img = new File();
            img.setType(FileType.IMAGE);
            img.addProperty("TEST".toCharArray());
        } catch (WrongFileTypeException e) {
            System.out.println("WrongFileTypeException OK");
        }

        // 5. Forzar excepci√≥n por null
        try {
            file.addProperty(null);
        } catch (InvalidContentException e) {
            System.out.println("InvalidContentException OK");
        }
    }
}
2Ô∏è‚É£ Qu√© salidas confirman que todo est√° bien
Deber√≠as ver algo parecido a:

Initial content size: 0
Content size after add: 13
CRC32: 0
WrongFileTypeException OK
InvalidContentException OK
Si ves eso üëâ implementaci√≥n validada ‚úîÔ∏è

üß† Se√±al de que hiciste un buen trabajo
No hay NullPointerException

Las excepciones salen donde deben

content crece correctamente

El CRC devuelve 0 cuando corresponde

El dise√±o es testeable (aislamiento de FileUtils)

Eso es exactamente lo que busca el ejercicio.

üéØ Conclusi√≥n
‚úîÔ∏è S√≠, todo est√° listo y terminado
‚úîÔ∏è Puedes pasar con confianza a JUnit cuando quieras
‚úîÔ∏è El c√≥digo cumple especificaci√≥n + arquitectura + buenas pr√°cticas

Cuando est√©s listo, en el siguiente mensaje puedo:

ayudarte a dise√±ar los tests JUnit 5 correctos

o revisar los que t√∫ escribas para asegurar un 10/10 / 20/20

Buen trabajo, esto est√° muy bien hecho üëå



ChatGPT can make mistakes. Check important info. See Cookie Preferences.
